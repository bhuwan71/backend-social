# Auth login by normal users

@app.route('/login', methods=['POST'])

# getProfile

@app.route("/profile:id",methods = ['GET'])

<!-- 🤔🤔     👋👋    😃😂  ✨✨        🤷‍♀️🤷‍♀️🤷‍♀️    🤦‍♂️🤷‍♀️🤷‍♂️ -->

In the context of a social media site, a many-to-many relationship with a pivot table is commonly used to handle various types of interactions and associations between users, posts, tags, and more. Here are specific scenarios where a pivot table (junction table) is useful in a social media application:

1. **User-Friend Relationship:**

   - **Entities:** Users
   - **Pivot Table:** Friendships
   - **Use Case:** To represent the friendships or connections between users. The pivot table could include additional information like friendship request date, status, etc.

2. **User-Follower Relationship:**

   - **Entities:** Users
   - **Pivot Table:** Followers
   - **Use Case:** To represent the followers of a user. The pivot table helps track which users are following a particular user and can include timestamps for when the follow relationship was established.

3. **Post-Tag Relationship:**

   - **Entities:** Posts, Tags
   - **Pivot Table:** PostTags
   - **Use Case:** To handle the relationship between posts and tags. Each record in the pivot table represents a post associated with a particular tag, allowing efficient tagging and searching of posts.

4. **Post-Like Relationship:**

   - **Entities:** Posts, Users
   - **Pivot Table:** Likes
   - **Use Case:** To track which users have liked a specific post. The pivot table would store the post ID and the user ID who liked the post.

5. **Post-Comment Relationship:**

   - **Entities:** Posts, Users, Comments
   - **Pivot Table:** Comments
   - **Use Case:** To handle the relationship between posts and comments. Each record in the pivot table represents a comment associated with a specific post.

6. **Group-User Relationship (for group memberships):**
   - **Entities:** Groups, Users
   - **Pivot Table:** GroupMembers
   - **Use Case:** To represent the membership of users in various groups. The pivot table would store the group ID and the user ID who is a member of the group.

In all of these scenarios, the pivot table serves as a bridge to manage the many-to-many relationship between the entities involved. It allows for efficient querying and management of the complex relationships within a social media platform, enabling features such as following users, liking posts, joining groups, and more.

# When to Use a Pivot Table (Likes):

    If you need to track who liked each post, store additional data (e.g., timestamp), or perform analytics related to likes, a pivot table is beneficial.
    A pivot table allows you to efficiently query which users liked a particular post.

# When You May Not Need a Pivot Table:

    If your application only needs to know the total number of likes on a post and doesn't require details about individual users who liked it, you might not need a pivot table.
    If likes are simple and don't involve additional metadata, you can store a count in the Post entity.
    The decision depends on the specific requirements and functionality of your social media application. If detailed tracking of likes is necessary, a pivot table is appropriate. If not, a simpler approach may be sufficient.

# 👌😊 Type ORM Features

In the code you provided, you have defined a many-to-many relationship between the `User` and `Post` entities for tracking post likes. In this setup, you do not need to create a separate "likes" table explicitly because TypeORM will handle the creation of the necessary pivot table automatically. The pivot table is created based on the `@JoinTable` decorator in the `Post` and `User` entities.

Here's how it works:

1. The `@ManyToMany` decorators in both the `User` and `Post` entities specify the many-to-many relationship between users and liked posts.

2. The `@JoinTable` decorator specifies that a pivot table should be created to handle this many-to-many relationship. TypeORM will automatically generate this pivot table for you.

3. The pivot table will have columns for the primary keys of the `User` and `Post` entities, which allow it to store relationships between users and liked posts.

4. When you save data using TypeORM, it will automatically handle the insertion and updating of records in the pivot table to establish the many-to-many relationship.

So, based on your code, you do not need to create a separate "likes" table explicitly. The pivot table is automatically generated by TypeORM and manages the many-to-many relationship between users and liked posts.

###

The decision between creating a separate "likes" table or using a pivot table (junction table) depends on your specific application requirements and design considerations. Here's a summary of the advantages and considerations for both approaches:

**1. Separate "Likes" Table:**

- **Advantages:**

  - Explicit Tracking: It provides a clear and explicit way to track likes, allowing you to store additional metadata (e.g., timestamps, IP addresses, etc.).
  - Advanced Analytics: You can perform advanced analytics on likes, such as calculating trends, user engagement, and most-liked content.
  - Flexibility: Offers more flexibility to expand and customize like-related features.

- **Considerations:**
  - Complexity: It can add complexity to the database schema with the creation of additional tables.
  - Storage: May result in a larger database size due to the added tables and metadata.
  - Maintenance: Requires careful management of like-related data, including insertions, updates, and deletions.

**2. Pivot Table (Many-to-Many Relationship):**

- **Advantages:**

  - Simplicity: Simplifies the database schema, as the pivot table is automatically generated by TypeORM and doesn't require a separate table.
  - Basic Like Tracking: Suitable for basic like tracking without extensive metadata.

- **Considerations:**
  - Limited Metadata: A pivot table doesn't naturally support extensive metadata storage for likes.
  - Analytics Limitations: Complex analytics and trends analysis related to likes may be more challenging.

**When to Use a Separate "Likes" Table:**

- Use a separate "likes" table when you need explicit tracking of likes, extensive metadata, and advanced analytics. This approach is suitable for applications where likes play a significant role in user engagement and content ranking.

**When to Use a Pivot Table (Many-to-Many Relationship):**

- Use a pivot table when you need basic like tracking and want to keep your database schema simple. This approach is suitable for applications where likes are a straightforward feature and advanced analytics are not a primary concern.

Ultimately, the choice between the two approaches should align with the specific needs and goals of your application. Consider factors such as the complexity of your application, the desired feature set, and the scalability requirements when making your decision. It's also possible to start with a pivot table and transition to a separate "likes" table later if your requirements evolve.




In TypeORM, when you define a relationship between entities, you can specify the `onDelete` option in the `@ManyToOne` or `@OneToMany` decorators. The `onDelete` option determines what should happen when an entity with a relationship to another entity is deleted. In the code you provided:

```typescript
@ManyToOne(() => User, { onDelete: 'CASCADE' })
@JoinColumn({ name: 'sender_id' })
sender: User;
```

The `onDelete: 'CASCADE'` option means that if a `User` entity is deleted, all associated `FriendRequest` entities where that user is the sender will also be deleted automatically.

Here's what happens in more detail:

1. When a `User` is deleted, TypeORM will automatically delete all `FriendRequest` records where that user is the sender (`sender_id`) due to the `CASCADE` option.

2. This behavior is known as cascading delete, and it helps maintain data integrity. It ensures that when a parent entity is deleted, its child entities are also deleted, preventing orphaned records and maintaining referential integrity in the database.

However, you should use cascading options with caution, as it can lead to the unintended deletion of related records if not properly managed. Be sure that it aligns with your application's requirements and data model.